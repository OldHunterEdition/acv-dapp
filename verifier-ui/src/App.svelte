<script>
  import { onMount } from "svelte";
  import { ethers } from "ethers";
  import { CERT_REGISTRY_ABI } from "./lib/abi";
  // Auto-generated by scripts/sync-verifier.js
  import { AUTO_CONTRACT_ADDRESS, AUTO_CHAIN_ID, AUTO_CERT_ID, AUTO_CID, AUTO_CONTENT_HASH } from "./lib/autoConfig";

  // === Defaults (can be overridden by URL params) ===
  // Force local RPC so we always hit Ganache (change if you want Sepolia)
  const DEFAULT_RPC = "http://127.0.0.1:8545";
  let rpcUrl = DEFAULT_RPC;

  let contractAddress = AUTO_CONTRACT_ADDRESS || "0x";
  let chainId = AUTO_CHAIN_ID || 1337;
  let certId = AUTO_CERT_ID || ""; // 0x... (bytes32)

  // UI state
  let result = "";
  let details = "";
  let loading = false;
  let pdfUrl = "";
  let metadataUrl = "";

  // URL params override defaults
  onMount(() => {
    const p = new URLSearchParams(window.location.search);
    contractAddress = p.get("contract") || contractAddress;
    certId = p.get("certId") || certId;
    chainId = Number(p.get("chainId") || chainId);
  });

  // Prefer direct RPC (Ganache). Only use MetaMask if you clear rpcUrl.
  async function getProvider() {
    if (rpcUrl) {
      return new ethers.JsonRpcProvider(rpcUrl);
    }
    if (window.ethereum) {
      const provider = new ethers.BrowserProvider(window.ethereum);
      const net = await provider.getNetwork();
      if (chainId && Number(net.chainId) !== Number(chainId)) {
        try {
          await window.ethereum.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: "0x" + chainId.toString(16) }],
          });
        } catch (_) {
          /* ignored */
        }
      }
      return provider;
    }
    throw new Error("No RPC or wallet found.");
  }

  function statusToText(n) {
    if (n === 1) return "Active";
    if (n === 2) return "Revoked";
    return "None";
  }

  async function verify() {
    result = "";
    details = "";
    pdfUrl = "";
    metadataUrl = "";
    loading = true;
    try {
      if (!ethers.isHexString(certId, 32)) {
        throw new Error("certId must be a 32-byte hex string (0x... length 66).");
      }
      if (!ethers.isAddress(contractAddress)) {
        throw new Error("Contract address is not a valid 0x address.");
      }

      const provider = await getProvider();

      // Sanity check: make sure there's bytecode at the address
      const code = await provider.getCode(contractAddress);
      if (!code || code === "0x") {
        throw new Error("No contract deployed at this address on the current chain.");
      }

      const contract = new ethers.Contract(contractAddress, CERT_REGISTRY_ABI, provider);

      // 1) Read on-chain record
      const c = await contract.get(certId);
      const cid = c.cid; // tuple key
      const onchainHash = c.contentHash; // bytes32
      const status = Number(c.status); // 0=None, 1=Active, 2=Revoked

      if (!cid) throw new Error("No record found for this certId (did you issue it on this chain?).");

      pdfUrl = `https://gateway.pinata.cloud/ipfs/${cid}/certificate.pdf`;
      metadataUrl = `https://gateway.pinata.cloud/ipfs/${cid}/metadata.json`;

      details =
        `Issuer: ${c.issuer}\n` + `CID: ${cid}\n` + `IssuedAt: ${c.issuedAt}\n` + `RevokedAt: ${c.revokedAt}\n` + `Status: ${statusToText(status)} (${status})\n` + `On-chain hash: ${onchainHash}`;

      if (status !== 1) {
        result = "❌ Not Active (maybe revoked or missing)";
        loading = false;
        return;
      }

      // 2) Fetch PDF from IPFS and hash it
      const res = await fetch(pdfUrl);
      if (!res.ok) throw new Error(`Failed to fetch PDF from IPFS (${res.status})`);
      const bytes = new Uint8Array(await res.arrayBuffer());
      const localHash = ethers.keccak256(bytes);

      // 3) Compare hashes
      result = localHash.toLowerCase() === onchainHash.toLowerCase() ? "✅ VALID: on-chain hash matches the IPFS PDF" : "❌ INVALID: hash mismatch";
    } catch (e) {
      result = "❌ Error";
      details = e?.message || String(e);
    } finally {
      loading = false;
    }
  }
</script>

<main style="max-width: 800px; margin: 2rem auto; font-family: system-ui, sans-serif;">
  <h1>Academic Certificate Verifier</h1>

  <div style="display:grid; gap:0.75rem; margin:1rem 0;">
    <label>
      Contract address
      <input bind:value={contractAddress} placeholder="0x..." style="width:100%; padding:0.5rem;" />
    </label>

    <label>
      Chain ID
      <input type="number" bind:value={chainId} style="width:100%; padding:0.5rem;" />
    </label>

    <label>
      certId (bytes32)
      <input bind:value={certId} placeholder="0x..." style="width:100%; padding:0.5rem;" />
    </label>

    <button on:click={verify} disabled={loading} style="padding:0.6rem 1rem;">
      {loading ? "Verifying..." : "Verify"}
    </button>
  </div>

  {#if result}
    <h2>{result}</h2>
  {/if}

  {#if details}
    <pre style="white-space:pre-wrap; background:#0f172a15; padding:0.75rem; border-radius:8px;">{details}</pre>
  {/if}

  {#if pdfUrl}
    <p>
      <a href={pdfUrl} target="_blank" rel="noreferrer">Open certificate.pdf</a>
      &nbsp;|&nbsp;
      <a href={metadataUrl} target="_blank" rel="noreferrer">Open metadata.json</a>
    </p>
  {/if}

  <p style="margin-top:1rem; font-size:0.9rem;">
    Tip: append <code>?contract=0x...&certId=0x...&chainId=11155111</code> to the URL to prefill.
  </p>
</main>
